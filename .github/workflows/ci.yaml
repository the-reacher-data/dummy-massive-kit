name: CI

on:
  push:
    branches: ["feature/**", "multifeature/**", "fix/**", "hotfix/**", "chore/**", "docs/**"]
  pull_request:
    branches: ["main"]

env:
  PYTHON_VERSION: "3.11"

jobs:
  quality:
    runs-on: ubuntu-latest
    outputs:
      tests: ${{ steps.pytest.outputs.results }}
      coverage: ${{ steps.pytest.outputs.coverage }}
      lint: ${{ steps.lint.outputs.errors }}
      types: ${{ steps.types.outputs.errors }}
      bandit: ${{ steps.bandit.outputs.issues }}
      snyk: ${{ steps.snyk.outputs.issues }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - uses: astral-sh/setup-uv@v3

      - run: uv sync --group ci

      - id: lint
        run: |
          if uv run ruff check . > lint.log 2>&1; then
            echo "errors=0" >> $GITHUB_OUTPUT
          else
            ERR=$(grep -c "error" lint.log || echo "1")
            echo "errors=$ERR" >> $GITHUB_OUTPUT
            exit 1
          fi

      - id: types
        run: |
          if uv run mypy src > types.log 2>&1; then
            echo "errors=0" >> $GITHUB_OUTPUT
          else
            ERR=$(grep -c "error:" types.log || echo "1")
            echo "errors=$ERR" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: ðŸ§ª Run Tests
        id: pytest
        uses: pavelzw/pytest-action@v2
        with:
          test_root: src/tests/
          coverage: src/
          coverage_threshold: 85
          coverage_fail_under: 85
          verbose: true
          fail_fast: false
        env:
          PYTHONPATH: src/

      - name: ðŸ“Š Upload Coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ./coverage.xml
          fail_ci_if_error: false
          verbose: true
        if: always()

      - name: ðŸ“ˆ Extract Coverage Percentage
        id: coverage
        run: |
          if [ -f coverage.xml ]; then
            COVERAGE=$(python3 -c "
            import xml.etree.ElementTree as ET
            try:
            tree = ET.parse('coverage.xml')
            root = tree.getroot()
            packages = root.find('packages')
            if packages is not None:
              total_coverage = 0
              total_files = 0
              for package in packages.findall('package'):
                for file in package.findall('file'):
                  if 'line-rate' in file.attrib:
                      total_coverage += float(file.attrib['line-rate']) * 100
                      total_files += 1
              if total_files > 0:
                print(f'{total_coverage / total_files:.1f}')
              else:
                print('0.0')
            else:
              print('0.0')
          except Exception:
            print('0.0')
            print('0.0')
            )
            echo "coverage=${COVERAGE}" >> $GITHUB_OUTPUT
            echo "Coverage: ${COVERAGE}%"
          else:
            echo "coverage=0" >> $GITHUB_OUTPUT
            echo "âš ï¸ No coverage.xml found"
          fi
        shell: bash

      - name: ðŸ“‹ Test Summary
        id: test-summary
        run: |
          if [ -f pytest.xml ]; then
            # Parse JUnit XML for test counts (install xmlstarlet if needed)
            if command -v xmlstarlet &> /dev/null; then
              PASSED=$(xmlstarlet sel -t -v "//testcase[count(failure)=0]" pytest.xml 2>/dev/null | wc -l || echo "0")
              FAILED=$(xmlstarlet sel -t -v "//testcase/failure" pytest.xml 2>/dev/null | wc -l || echo "0")
              SKIPPED=$(xmlstarlet sel -t -v "//testcase/skipped" pytest.xml 2>/dev/null | wc -l || echo "0")
            else
              # Fallback: simple log parsing
              PASSED=$(grep -c " PASSED " pytest.log 2>/dev/null || echo "0")
              FAILED=$(grep -c " FAILED " pytest.log 2>/dev/null || echo "0")
              SKIPPED=$(grep -c " SKIPPED " pytest.log 2>/dev/null || echo "0")
            fi
            TOTAL=$((PASSED + FAILED + SKIPPED))
          else
            # No test results available
            PASSED=0
            FAILED=0
            SKIPPED=0
            TOTAL=0
          fi

          echo "results=${PASSED}/${TOTAL} (${SKIPPED} skipped)" >> $GITHUB_OUTPUT
          echo "Tests: ${PASSED} passed, ${FAILED} failed, ${SKIPPED} skipped"

          # Fail if tests failed
          if [ "$FAILED" -gt 0 ]; then
            echo "âŒ ${FAILED} tests failed"
            exit 1
          fi
        shell: bash

      - id: bandit
        run: |
          if uv run bandit -r src -f json -o bandit.json; then
            echo "issues=0" >> $GITHUB_OUTPUT
          else
            COUNT=$(jq '.results | length' bandit.json || echo 1)
            echo "issues=$COUNT" >> $GITHUB_OUTPUT
          fi

      - id: snyk
        uses: snyk/actions/python@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --json-file-output=snyk.json
          run: |
            COUNT=$(jq '.vulnerabilities | length' snyk.json || echo 0)
            echo "issues=$COUNT" >> $GITHUB_OUTPUT

      - uses: codecov/codecov-action@v4
        if: github.event_name == 'pull_request'
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.xml
          fail_ci_if_error: false

      - uses: actions/upload-artifact@v4
        with:
          name: ci-artifacts
          path: |
            pytest.log
            coverage.xml
            lint.log
            types.log
            bandit.json
            snyk.json

  prerelease:
    runs-on: ubuntu-latest
    needs: quality
    if: |
      needs.quality.result == 'success' &&
      (startsWith(github.ref, 'refs/heads/feature/') ||
       startsWith(github.ref, 'refs/heads/multifeature/') ||
       startsWith(github.ref, 'refs/heads/fix/') ||
       startsWith(github.ref, 'refs/heads/hotfix/') ||
       github.event_name == 'pull_request')
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - uses: astral-sh/setup-uv@v3
      - run: uv sync --group build
      - name: Dry-run semantic-release
        id: semrel
        uses: cycjimmy/semantic-release-action@v4
        with:
          semantic_version: 20
          extra_plugins: |
            @semantic-release/changelog
            @semantic-release/git
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true
      - run: |
          echo "Next version (predicted): ${{ steps.semrel.outputs.new_release_version }}"

  pr-comment:
    runs-on: ubuntu-latest
    needs: [quality, prerelease]
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const tests = "${{ needs.quality.outputs.tests }}";
            const cov = "${{ needs.quality.outputs.coverage }}";
            const lint = "${{ needs.quality.outputs.lint }}";
            const types = "${{ needs.quality.outputs.types }}";
            const bandit = "${{ needs.quality.outputs.bandit }}";
            const snyk = "${{ needs.quality.outputs.snyk }}";
            const version = "${{ needs.prerelease.outputs.new_release_version || 'n/a' }}";
            const body = `
            ## ðŸŽ¯ CI/CD Summary
            - **Tests**: ${tests} (coverage ${cov}%)
            - **Lint errors**: ${lint}
            - **Type errors**: ${types}
            - **Bandit issues**: ${bandit}
            - **Snyk vulnerabilities**: ${snyk}
            - **Next version (predicted)**: ${version}
            `;
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number;
            const comments = await github.rest.issues.listComments({owner, repo, issue_number});
            const existing = comments.data.find(c => c.body.includes("## ðŸŽ¯ CI/CD Summary"));
            if (existing) {
              await github.rest.issues.updateComment({owner, repo, comment_id: existing.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number, body});
            }
